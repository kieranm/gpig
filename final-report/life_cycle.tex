\section{Development Life Cycle}

\subsection{Planning}

Prior to the design and implementation of our system, we first established the fundamental requirements. We had deliberated and defined the core functionality of our system prior to the submission of the initial report. We therefore spent this stage predominantly determining what aspects of the system we needed to simulate to deliver maximum value. We agreed that we wanted to produce a rich high-level simulation, illustrating the movement of cargo through the whole system. At this stage, we also designated writing tasks to members of the team. Further details of our planning and organisation procedure are discussed in Section \ref{sec:group_evaluation}.

\subsection{Analysis}

Following on from the analysis we carried out for the initial system report, we investigated further potential advantages of our system and how these could best be represented by our simulation. We also considered the customer's additional requirements, and established how we could incorporate these into the software. We analysed a range of software languages and libraries, creating a shortlist of those with the most potential. We created very basic prototypes to establish which of these tools we would carry forward to full implementation. We chose to use Deck.gl and Mapbox owing to their powerful 3D visualisation capabilities. After further discussion, we decided that Java was the most apprioriate language in which to write our back-end model, with communication between the components taking place over websockets. 

\subsection{Design}

We then embarked on a design phase. This phase was coordinated by the Lead Architect and supported by the Lead Engineer. During this phase, we defined the architecture of the whole OceanX system, before deciding how best to translate this into a simulation model. We created high-level class diagrams, and designed a JSON communication interface that would allow information to flow between the front end and back end. 

\subsection{Implementation}

During the implementation phase, the Lead Engineer established whether team members would be more comfortable developing front-end or back-end components, and allocated tasks accordingly. Our common communication interface enabled simultaneous development of these features. Whenever a team member made a code pull request, or if any bugs in the software were found, members of both the front-end and back-end development teams would meet to establish the impact on their respective tiers, and what work would be required from each. Before code was merged into the master branch, we always performed a peer review process using Github. We set a feature freeze date, Saturday 27th May, after which new features would not be added. This date, together with our internal development schedule, gave us clear a clear timetable to follow.

\subsection{Testing and Integration}

We carried out the majority of our system testing through visual evaluation of the simulation. We compared our simulation engine to similar tools in order to ensure the system's behaviour was realistic. We integrated comprehensive debugging facilities into our software, in order to log a range of statistics and to allow closer inspection of ports simply by hovering the cursor over their visual representation. Given more time, it would have been useful to add formal unit and integration tests, along with continuous integration to detect any errors before they are merged into the master branch.




